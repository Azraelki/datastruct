1、树的定义
    树是由N个结点组成的有限集合,N=0时，称为空树.任意非空树应满足:
         1) 有且仅有一个根结点.
         2) 当N > 1时，除根节点外,其余结点可分为n个互不相交的有限集合S1,S2,S3,...,Sn,其中每一个
            集合本身又是一棵树,并且称为根结点的子树.


2、常见的树列表
    二叉搜索树(BST)
    平衡二叉树(AVL)
    红黑树(Red-Black Tree)
    B树(Balance Tree)
    B+树
    字典树(Trie)

3、分树种介绍
    1、树的定义及约束介绍
    2、树的优缺点
    3、树的构建、插入、删除关键点介绍
    4、树的性能介绍
    5、树的应用场景介绍
    二叉树：
        斜树：+图
            所有节点都只有左子树或者右子树，最差的二叉树，退化成了链表
        满二叉树：+图
            所有节点都有左子树和右子树，且所有叶子节点都在同一层，是最完美的二叉树
        完全二叉树：+图
            当按层从左到右对节点标序号后，节点的序号和满二叉树同位置节点的序号完全一致时则称为完全二叉树
        二叉搜索树:
            1、约束:
                1、每个结点至多拥有左右两棵子树
                2、若节点左子树不为空,则左子树上所有节点值均小于当前节点值
                3、若节点右子树不为空,则右子树上所有节点值均大于当前节点值
            2、优缺点
                优点:
                    查找、插入、删除效率相比链式结构都快
                缺点:
                    树的操作性能取决于树的形状(构建的数据有关，和构建时的数据顺序也有关)
                    极端情况下退化为链表
            3、操作关键点介绍
                删除：
                    1）、删除节点为叶子节点，直接删除
                    2) 、删除节点仅有左子树或者右子树，则直接将左子树或又子树代替当前节点
                    3）、删除节点既有左子树又有右子树，此时有两种选择 +图
                        1）、获取前驱节点，将前驱节点替换为当前节点(前驱节点为当前节点左孩子的最右子树)
                            以前驱节点为起始节点，若前驱节点有子树，则必为左子树，此时符合步骤2
                        2）、获取后继节点，将后继节点替换为当前节点(后继节点为当前节点右孩子的最左子树)
                            以后继节点为起始节点，若后继节点有子树，则必为右子树，此时符合步骤2
            4、性能介绍
                最好:o(1)，根节点即为目标节点
                平均:o(log(n)),近似为二分查找
                最差:o(n),等价于顺序查询
            5、树的应用场景
                因为其缺点较为明显，应用场景较少，主要用于教学介绍

        平衡二叉树
            1、约束：
                1、是一颗二叉树
                2、每个节点左子树和又子树的高度相差小于等于1(也可理解为节点的|平衡因子|<=1)
            2、优缺点
                优点：查找、插入、删除都比较快
                缺点：在插入删除时为了保持树的绝对平衡，需要频繁进行旋转
            3、操作关键点介绍
                左旋：+图
                    当前节点变为右节点的左节点，右节点原来的左节点变为当前节点的右节点
                右旋：+图
                    当前节点变为左节点的右节点，左节点原来的右节点变为当前节点的左节点
                平衡因子：左子树高度-右子树高度
                自平衡操作：
                    1、平衡因子大于1时（左子树高于右子树）
                        1）、当失衡节点的左子树平衡因子大于等于0时，以失衡节点为支点右旋 --左左
                        2）、当失衡节点的左子树平衡因子小于0时(失衡节点左子树的右子树高于左子树)，
                             先以失衡节点的左子树为支点进行左旋，此时回到状态1) --左右
                    2、平衡因子小于-1时(右子树高于左子树)
                        1）、当失衡节点的右子树平衡因子小于等于0时，以失衡节点为支点左旋 --右右
                        2)、当失衡节点的右子树平衡因子大于0时，先以失衡节点的右子树为支点进行右旋，此时回到状态1） --右左
                插入：+图
                    以插入的节点向上遍历，当遇到失衡节点时执行自平衡操作
                删除：+图
                    删除一个节点时，将删除节点的前驱/后继节点替换为当前节点，并以前驱/后继节点为新的删除节点向上遍历
                    当遇到失衡节点时执行自平衡操作
            4、性能
                最好:o(1)
                平均:o(log(n))
                最差:o(log(n))

            5、树的应用场景
                Windows运用AVL树对进程地址空间的管理
                原因从avl树的特点来看可能是查询操作更快
        红黑树
            1、约束：
                1、节点颜色为红色或者黑色
                2、根节点为黑色
                3、父子节点不能出现连续两个红色节点
                4、从根节点触发到叶子节点，任意路径上黑色节点的数量相同
            2、优缺点
                优点：查找、插入、删除都比较快
                缺点：插入和删除时会破坏约束，需要进行变色和旋转保持平衡
                     树的形状不再维持绝对平衡，最长路径可能是最短路径的两倍
                     (可以认为是2-3-4树宽度到高度的退化)
            3、操作关键点介绍
                变色：失衡节点的颜色变为红色，失衡节点的做孩子和右孩子都变为黑色
                左旋：基础左旋，并把支点颜色变为红色，支点右节点变为黑色
                右旋：基础右旋，并把支点颜色变为红色，支点左节点变为黑色
                插入：
                    1、插入节点的父节点是黑色，则直接插入红色节点
                    自平衡操作：
                        2、插入节点的父节点和叔父节点同红，则进行变色操作，并以祖父节点作为新的插入节点向上递归
                        3、插入节点的父节点为红色，叔父节点为黑色(此时考虑父节点是祖父节点的左子树)
                            1）、如果插入节点在父节点的左子树上，直接以祖父节点为支点进行右旋
                            2)、如果插入节点在父节点的右子树上，先以父节点进行左旋，此时回到了状态 1)
                        4、父节点是祖父节点的右子树时，为3、的镜像操作
                删除：
                    1、删除节点为红色叶子节点，直接删除
                    2、删除节点为黑色叶子节点，直接删除，并从此节点开始向上递归，进行自平衡操作
                    3、删除节点为中间节点，则找到对应的后继/前驱节点，将后继/前驱节点的值替换为删除节点
                       并以后继/前驱节点开始向上递归，进行自平衡操作，自平衡操作和插入保持一致
            4、性能
                最好：o(1)
                平均：o(log(n))
                最差:o(2long(n))
            5、应用场景
                1、IO多路复用epoll的实现采用红黑树组织管理sockfd，以支持快速的增删改查.
                2、ngnix中,用红黑树管理timer,因为红黑树是有序的,可以很快的得到距离当前最小的定时器.
                3、c++中STL，java中的TreeMap、HashMap

    多路搜索树：
        B树：
            1、约束
                1、一颗m阶的B树，每个节点最多有m-1个关键字，根节点最少可以只有1个关键字
                2、非根节点至少要有max(1, ceil(m/2)-1)个关键字
                3、每个节点中关键字按顺序排列，每个关键字的左子树都小于它，右子树都大于它
                4、所有的叶子节点都在同一层
            2、优缺点
                优点：
                    降低了树的高度，查询近似于对全集进行一次二分查找
                缺点：
                    性能不稳定，因为数据可能在树中的中间检点或者叶子节点
                    遍历麻烦，需要遍历整棵树
            3、操作关键点
                插入：
                    分裂：
                        1、节点满阶时，找到节点的中间键，并将中间键上升到父节点
                        2、将节点中间键右侧的键和子节点分离成一个新的节点，作为中间键的后继节点
                        3、中间键左侧的键和节点保留在原节点，作为中间键的前驱节点
                    1、当插入节点导致满阶时，进行分裂操作，并递归向上进行
                删除：
                    补充节点：

                    1、当删除的关键字为中间节点时，先找到删除节点的后继节点，将删除的键替换为后继节点的最小键
                    2、以当前替换键的右子树为根，后继节点最小键为删除值继续进行
                    3、判定删除关键字后节点中关键字的数量是否小于限制，若小于则执行下面步骤
                        1、当兄弟节点中有富余的节点，则将父关键字下沉到当前节点，将兄弟节点中的最左关键字/最右关键字作为新的父关键字
                        2、当兄弟节点中没有富余的节点，则将父关键字和当前节点、兄弟节点合为一个节点，
                           并将父节点作为新的删除节点进行向上递归

            4、性能：
                数据全部在内存时弱于平衡二叉树
                数据在外存时优于平衡二叉树

            5、应用场景
                1、数据库数据索引
                2、文件系统用于元数据索引

        B+树
            1、约束
                在B树的基础上
                1、所有的数据均存于叶子节点上，节点上只存放索引关键字
                2、每个叶子节点身上存有相邻叶子节点的指针，且叶子节点从左到右顺序排列
            2、优缺点
                优点
                    1、可以方便进行顺序遍历及区间查询
                    2、性能稳定，所有命中节点都在叶子节点
                缺点：
                    和B树一样对于节点的利用率较少，极端情况下只有一半的利用率
            3、操作关键点
                    所有的中间节点都为索引节点
                插入
                    1、插入节点都在叶子节点上
                    2、当叶子节点满阶时，分裂节点，并把分裂后的其中一个的最左或最右的关键字上浮为索引节点
                    3、以插入叶子节点的父节点作为新的插入节点，进行向上递归，索引节点的分裂和B树一致
                删除
                    1、若删除节点在叶子节点上
                    2、叶子节点小于约束值时，且兄弟节点有富余时，将兄弟节点的最左或最右键借过来，并将老的父关键字替换为借来的键值
                        若兄弟节点不富裕时，将兄弟节点和和当前节点合并，并删除老的父关键字
                    3、以删除节点的父节点作为新的删除节点，向上递归，索引节点的合并操作和B树一致
             4、性能
                等价于一次二分查找
             5、应用场景
                1、数据库数据索引
                2、文件系统用于元数据索引
    字典树：
        又叫前缀树
        优缺点
            最大限度地减少无谓的字符串比较，查询效率比较高
            浪费的空间比较大

        应用场景
            1、词频统计
            2、输入提示
            3、分词，双数组字典树

    赫夫曼树
        哈夫曼编码
        应用场景
            压缩

4、总结

